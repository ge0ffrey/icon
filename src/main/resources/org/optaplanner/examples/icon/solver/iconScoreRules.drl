package org.optaplanner.examples.icon;

import java.util.Set;
import java.math.BigDecimal;
import java.math.RoundingMode;

import org.optaplanner.core.api.score.buildin.hardsoftbigdecimal.HardSoftBigDecimalScoreHolder;
import org.optaplanner.examples.icon.domain.Resource;
import org.optaplanner.examples.icon.domain.Task;
import org.optaplanner.examples.icon.domain.TaskAssignment;
import org.optaplanner.examples.icon.domain.Machine;
import org.optaplanner.examples.icon.domain.MachineCapacity;
import org.optaplanner.examples.icon.domain.Period;
import org.optaplanner.examples.icon.domain.PeriodPowerCost;

global HardSoftBigDecimalScoreHolder scoreHolder;
global BigDecimal costMultiplier;

// ################ declared types ########################

declare MachineActivated
    machine: Machine
    on: Period
end

declare MachineDeactivated
    machine: Machine
    after: Period
    shutdown: boolean
end

declare ActiveMachine
    during: Period
    machine: Machine
end

declare MachineIdle
    machine: Machine
    since: Period // exclusive
    until: Period // exclusive
    shutdownCost: BigDecimal
    idleCost: BigDecimal
end

// ################# shared stuff ###########################

rule "Determine cost multiplier"
salience 1000 // run absolute first
when
    $total: Set() from collect(
        Period()
    )
then
    BigDecimal minutesInDay = BigDecimal.valueOf(1440);
    BigDecimal numOfPeriods = BigDecimal.valueOf($total.size());
    BigDecimal resolution = minutesInDay.divide(numOfPeriods); // minutes per period
    BigDecimal sixty = BigDecimal.valueOf(60); // hours per period
    drools.getWorkingMemory().setGlobal("costMultiplier", resolution.divide(sixty, 3, RoundingMode.HALF_UP));
end

rule "Is Machine active at a given time?"
salience 900 // reused by most other rules; run near first
when
    $m: Machine()
    $p: Period()
    exists TaskAssignment(executor == $m, $p >= startPeriod, $p <= finalPeriod)
then
    insertLogical(new ActiveMachine($p, $m));
end

// ################# hard constraints ###########################

rule "Uninitialized task assignments"
when
    TaskAssignment(!isInitialized());
then
    scoreHolder.addHardConstraintMatch(kcontext, BigDecimal.valueOf(1000000000).negate());
end

rule "Resource overuse per machine per period"
when
    ActiveMachine($p: during, $m: machine)
    MachineCapacity(machine == $m, $r: resource, $capacity: capacity)
    $use: Number(intValue > $capacity) from accumulate (
        TaskAssignment(
            isInitialized(),
            executor == $m,
            $p >= startPeriod,
            $p <= finalPeriod,
            $t: task
        );
        sum($t.getConsumption($r))
    )
then
    scoreHolder.addHardConstraintMatch(kcontext, BigDecimal.valueOf($capacity - $use.intValue()));
end

// ################# objective function ###########################

rule "Calculate costs for task power consumption, per task"
when
    $cost: BigDecimal() from accumulate(
        $t: TaskAssignment(isInitialized());
        sumBD($t.getPowerCost())
    )
then
    BigDecimal adjustedCost = $cost.multiply(costMultiplier);
    scoreHolder.addSoftConstraintMatch(kcontext, adjustedCost.negate());
end

rule "Detect machine becoming active"
salience 200 // run before idle detection
when
    ActiveMachine($p: during, $m: machine)
    not ActiveMachine(machine == $m, during.id == $p.id - 1) 
then
    insertLogical(new MachineActivated($m, $p));
end

rule "Detect machine becoming inactive"
salience 200 // run before idle detection
when
    ActiveMachine($p: during, $m: machine)
    not ActiveMachine(machine == $m, during.id == $p.id + 1) 
then
    insertLogical(new MachineDeactivated($m, $p, false));
end

rule "Detect periods without tasks"
salience 100 // run before score calculation
when
    MachineActivated($m: machine, $activation: on)
    MachineDeactivated(machine == $m, after < $activation, $latestShutdown: after)
    not MachineDeactivated(machine == $m, after < $activation, after > $latestShutdown) // find immediate previous deactivation
    $powerCosts: BigDecimal() from accumulate(
        PeriodPowerCost(period > $latestShutdown, period < $activation, $partial: cost);
        sumBD( $partial )
    )
then
    BigDecimal shutdownCost = $m.getCostOnShutdown().add($m.getCostOnStartup());
    BigDecimal actualCost = $m.getCostWhenIdle().multiply($powerCosts).multiply(costMultiplier);
    insertLogical(new MachineIdle($m, $latestShutdown, $activation, shutdownCost, actualCost));
end

rule "Penalize first startup"
when
    MachineActivated($m: machine, $activation: on, $cost: machine.costOnStartup, $cost > 0)
    not MachineDeactivated(machine == $m, after < $activation)
then
    scoreHolder.addSoftConstraintMatch(kcontext, $cost.negate());
end

rule "Penalize last shutdown"
when
    MachineDeactivated($m: machine, $deactivation: after, $cost: machine.costOnShutdown, $cost > 0)
    not MachineActivated(machine == $m, on >= $deactivation)
then
    scoreHolder.addSoftConstraintMatch(kcontext, $cost.negate());
end

rule "Aggregate shutdown/idle costs"
when
    $cost: BigDecimal() from accumulate(
        MachineIdle($idle: idleCost, $shutdown: shutdownCost);
        sumBD($idle.min($shutdown))
    )
then
    scoreHolder.addSoftConstraintMatch(kcontext, $cost.negate());
end

rule "Properly mark tasks to idle"
when
    $t: TaskAssignment($m: executor, $shutdown: finalPeriod)
    not MachineIdle(machine == $m, since == $shutdown, shutdownCost > idleCost)
then
    $t.setShutdownPossible(true);
end


rule "Properly mark tasks to shutdown"
when
    $t: TaskAssignment($m: executor, $shutdown: finalPeriod)
    exists MachineIdle(machine == $m, since == $shutdown, shutdownCost > idleCost)
then
    $t.setShutdownPossible(false);
end
