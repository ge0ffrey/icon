package org.optaplanner.examples.icon;

import java.util.Set;
import java.math.BigDecimal;
import java.math.RoundingMode;

import org.optaplanner.core.api.score.buildin.hardsoftbigdecimal.HardSoftBigDecimalScoreHolder;
import org.optaplanner.examples.icon.domain.Resource;
import org.optaplanner.examples.icon.domain.Task;
import org.optaplanner.examples.icon.domain.TaskAssignment;
import org.optaplanner.examples.icon.domain.Machine;
import org.optaplanner.examples.icon.domain.MachineCapacity;
import org.optaplanner.examples.icon.domain.Period;
import org.optaplanner.examples.icon.domain.PeriodPowerCost;

global HardSoftBigDecimalScoreHolder scoreHolder;
global BigDecimal costMultiplier;

// ################ declared types ########################

declare MachineHasTask
    during: Period
    machine: Machine
end

declare IdleSequence
    machine: Machine
    startsAfter: Period
    endsBefore: Period
    isShutdown: boolean
    cost: BigDecimal // either the cost of all the idle time, or cost of startup+shutdown
end

// ################# shared stuff ###########################

rule "Determine cost multiplier"
salience 1000 // run absolute first
when
    $total: Set() from collect(
        Period()
    )
then
    BigDecimal minutesInDay = BigDecimal.valueOf(1440);
    BigDecimal numOfPeriods = BigDecimal.valueOf($total.size());
    BigDecimal resolution = minutesInDay.divide(numOfPeriods); // minutes per period
    BigDecimal sixty = BigDecimal.valueOf(60); // hours per period
    drools.getWorkingMemory().setGlobal("costMultiplier", resolution.divide(sixty, 10, RoundingMode.HALF_UP));
end

rule "Is Machine active at a given time?"
salience 900 // reused by most other rules; run near first
when
    $m: Machine()
    PeriodPowerCost($p: period, $c: cost)
    exists TaskAssignment(executor == $m, $p >= startPeriod, $p <= finalPeriod)
then
    insertLogical(new MachineHasTask($p, $m));
    BigDecimal idleCost = $c.multiply($m.getCostWhenIdle()).multiply(costMultiplier);
    scoreHolder.addSoftConstraintMatch(kcontext, idleCost.negate());
end

rule "Resource overuse per machine per period"
when
    MachineHasTask($p: during, $m: machine)
    MachineCapacity(machine == $m, $r: resource, $capacity: capacity)
    $use: Number(intValue > $capacity) from accumulate (
        TaskAssignment(
            isInitialized(),
            executor == $m,
            $p >= startPeriod,
            $p <= finalPeriod,
            $t: task
        );
        sum($t.getConsumption($r))
    )
then
    scoreHolder.addHardConstraintMatch(kcontext, BigDecimal.valueOf($capacity - $use.intValue()));
end

rule "Calculate costs for task power consumption, per task"
when
    $cost: BigDecimal() from accumulate(
        $t: TaskAssignment(isInitialized());
        sumBD($t.getPowerCost())
    )
then
    BigDecimal adjustedCost = $cost.multiply(costMultiplier);
    scoreHolder.addSoftConstraintMatch(kcontext, adjustedCost.negate());
end

rule "Detect periods when machines have no tasks, decide if idle or startup+shutdown, and calculate costs properly"
salience 500 // run before other idle rules
when
    // first find an event where a task ends
    $endingTask: MachineHasTask($m: machine, $one: during)
    not MachineHasTask(machine == $m, during.id == $one.id + 1)
    // then find an event where immediately subsequent task starts
    $restartingTask: MachineHasTask(machine == $m, $two: during, during > $one)
    not MachineHasTask(machine == $m, during > $one, during < $two)
    // and calculate the idle costs
    $idleCost: BigDecimal() from accumulate(
        PeriodPowerCost(period > $one, period < $two, $cost: cost);
        sumBD($cost)
    ) 
then
    BigDecimal actualIdleCost = $idleCost.multiply($m.getCostWhenIdle()).multiply(costMultiplier);
    BigDecimal restartCost = $m.getCostOnStartup().add($m.getCostOnShutdown());
    boolean isShutdown = actualIdleCost.compareTo(restartCost) > 0;
    BigDecimal resultingCost = isShutdown ? restartCost : actualIdleCost;
    insertLogical(new IdleSequence($m, $one, $two, isShutdown, resultingCost));
end

rule "Penalize idle cycles"
when
    $s: IdleSequence($cost: cost)
then
    scoreHolder.addSoftConstraintMatch(kcontext, $cost.negate());
end

rule "Penalize first startup and last shutdown"
when
    $m: Machine()
    exists MachineHasTask(machine == $m)
then
    scoreHolder.addSoftConstraintMatch(kcontext, $m.getCostOnStartup().add($m.getCostOnShutdown()).negate());
end

rule "Properly marks shutdowns for the solution export"
when
    $t: TaskAssignment($m: executor, $p: finalPeriod)
    exists IdleSequence(isShutdown, machine == $m, startsAfter == $p)
then
    $t.setShutdownPossible(true);
end

rule "Properly marks idles for the solution export"
when
    $t: TaskAssignment($m: executor, $p: finalPeriod)
    not IdleSequence(isShutdown, machine == $m, startsAfter == $p)
then
    $t.setShutdownPossible(false);
end